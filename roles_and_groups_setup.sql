-- 1. UTILS/ROLES TABLE
create table user_roles (
  user_email text primary key,
  role text not null check (role in ('admin', 'group_order', 'user'))
);

-- Enable RLS
alter table user_roles enable row level security;

-- Allow public read of roles (so the app can check "Am I an admin?")
-- In a stricter app, we'd use a secure function, but this is fine for MVP.
create policy "Allow reading own role" on user_roles
  for select using (true);
  
-- Insert a demo admin (You can change this to your email)
insert into user_roles (user_email, role) values 
('admin@example.com', 'admin'),
('group@example.com', 'group_order');


-- 2. RE-CREATE MEALS TABLE FOR QUANTITY SUPPORT
-- Drop old table to start fresh with new schema
drop table if exists user_meals;

create table user_meals (
  id bigint generated by default as identity primary key,
  user_email text not null,
  meal_date text not null, -- YYYY-MM-DD
  veg_quantity int default 0,
  meat_quantity int default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_email, meal_date)
);

alter table user_meals enable row level security;

-- 3. POLICIES

-- Policy: Users/Group can read/write ONLY their own meals
create policy "Users manage own meals" on user_meals
  for all
  using (user_email = auth.jwt() ->> 'email')
  with check (user_email = auth.jwt() ->> 'email');

-- Policy: Admins can read ALL meals (for reports)
-- We rely on the app checking the role, but for RLS to enforce it securely:
-- We technically need a way to check 'user_roles' inside the policy.
-- A simple way for this MVP:
-- Allow SELECT if the requesting email exists in 'user_roles' with role 'admin'
create policy "Admins view all" on user_meals
  for select
  using (
    exists (
      select 1 from user_roles 
      where user_email = (select auth.jwt() ->> 'email') 
      and role = 'admin'
    )
  );
